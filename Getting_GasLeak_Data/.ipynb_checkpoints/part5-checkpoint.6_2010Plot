{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%%     \n",
    "# PLOTTING WITH GEOID, WESTCHESTER SHP NOT FOUND YET, NEED TO BLACK OUT BRROKLYN AND STATEN ISLAND\n",
    "# Plotting the census tracts for all reports that appeared in a specific month                    \n",
    "# import contextily as ctx\n",
    "# import matploylib.pyplot as plt\n",
    "import geopandas as gp\n",
    "import os\n",
    "import platform\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "# A) CREATING DF AND GDF:\n",
    "shapeFile = \"NYU_NYC_34505_SP/nyu_2451_34505.shp\"\n",
    "csvFile = \"GasHistory_2010_ReportFrequency_Monthly.csv\"\n",
    "brooklynFile = \"TIGER_2010_County_Shapefiles/BrooklynCounty_2010SHP/tl_2010_36047_tract10.shp\"\n",
    "statenFile = \"TIGER_2010_County_Shapefiles/StatenIslanCounty_2010SHP\"\n",
    "monthlyDF = pd.read_csv(csvFile)                                                                            # Read the csv file and make a data frame\n",
    "shapeGDF = gp.read_file(shapeFile)                                                                           # Read the shape file and make a data frame\n",
    "brooklynGDF = gp.read_file(brooklynFile)\n",
    "statenGDF = gp.read_file(statenFile)\n",
    "\n",
    "GDF_GEOID_COL = \"tractid\"\n",
    "DF_GEOID_COL  = \"GEOID_SCT\"\n",
    "MIN_NUM_TRACTS_NEEDED_TO_PRINT = 150 #max westchester got in a month is 110\n",
    "\n",
    "# B) ADDING NEW COLS TO SHAPEGDF AND CHANGING DATATYPE OF COLS SO WE CAN COMPARE THEM:\n",
    "shapeGDF[\"MonthYear\"] = str                                                                               # adding two new cols to shapeGDF\n",
    "shapeGDF[\"TotalMonthlyReport\" ] = int\n",
    "shapeGDF[\"CountyName\"] = str \n",
    "shapeGDF[\"CensusBlockID_list\"] = str  \n",
    "shapeGDF[\"Ticket_list\"] = str  \n",
    "shapeGDF[\"Classification_list\"] = str  \n",
    "shapeGDF[\"Zipcode_list\"] = str \n",
    "shapeGDF[\"CountyTract\"] = str\n",
    "shapeGDF[[GDF_GEOID_COL]] = shapeGDF[[GDF_GEOID_COL]].apply(pd.to_numeric).astype(int)                                      # Turning GDF_GEOID_COL - the CensusTract number to numpy.int64 values so can query them\n",
    "shapeGDF[['tractid']] = shapeGDF[['tractid']].apply(pd.to_numeric).astype(int)  \n",
    "shapeGDF[['tractnum']] = shapeGDF[['tractnum']].apply(pd.to_numeric).astype(int)  \n",
    "shapeGDF[['name']] = shapeGDF[['name']].apply(pd.to_numeric).astype(int) \n",
    "shapeGDF[['bcode']] = shapeGDF[['bcode']].apply(pd.to_numeric).astype(int) \n",
    "# print(\"======================================================================================================== RAW DATA: GDF and monthly DF ========================================================================================================\")\n",
    "# print(shapeGDF)\n",
    "# print(\"------------------------------------------------------------------------ monthly DF:------------------------------------------\")\n",
    "# print(monthlyDF)\n",
    "# print(\"=============================================================================================================== RAW DATA END =================================================================================================================\")\n",
    "\n",
    "shapeGDF.to_csv(\"del_monthly.csv\")\n",
    "# C) CON EDISON DOESNT INCLUDE DATA FROM STATEN ISLAND AND BROOKYLN SO GRAY THEM OUT\n",
    "# BROOKLYN OUTLINE GDF:\n",
    "print(\"Making Brooklyn and Staten Island Outline Maps...\\n\")\n",
    "bkGeoidList = list()\n",
    "for row in range(0, len(brooklynGDF)):\n",
    "    bkGeoidList.append(int(brooklynGDF.iloc[row][\"GEOID10\"]))\n",
    "brooklynOutlineGDF = shapeGDF.copy()\n",
    "brooklynOutlineGDF.drop(brooklynOutlineGDF.index, inplace=True)  \n",
    "skipGeoid = []\n",
    "for geoid in range(0, len(bkGeoidList)):        \n",
    "    bkGDF = shapeGDF.loc[                                                                               # thisMonthsDF = df that contains all rows for that month-year\n",
    "        (shapeGDF[GDF_GEOID_COL]  == bkGeoidList[geoid]) \n",
    "    ]  \n",
    "    if len(bkGDF)==0:\n",
    "        print(\"******************* GEOID \"+str(bkGeoidList[geoid])+\" Is in the brooklyn geoi shp but not in nyc shp\")\n",
    "    skipGeoid.extend(bkGDF.index.tolist())\n",
    "    bkGDF = bkGDF.reset_index(drop=True)\n",
    "    brooklynOutlineGDF = brooklynOutlineGDF.append(bkGDF)\n",
    "brooklynOutlineGDF.reset_index(drop=True)\n",
    "# STATEN ISLAND OUTLINE GDF:\n",
    "print(\"Making Brooklyn and Staten Island Outline Maps...\\n\")\n",
    "statenGeoidList = list()\n",
    "for row in range(0, len(statenGDF)):\n",
    "    statenGeoidList.append(int(statenGDF.iloc[row][\"GEOID10\"]))\n",
    "statenOutlineGDF = shapeGDF.copy()\n",
    "statenOutlineGDF.drop(statenOutlineGDF.index, inplace=True)  \n",
    "skipGeoid = []\n",
    "for geoid in range(0, len(statenGeoidList)):        \n",
    "    statenGDF = shapeGDF.loc[                                                                               # thisMonthsDF = df that contains all rows for that month-year\n",
    "        (shapeGDF[GDF_GEOID_COL]  == statenGeoidList[geoid]) \n",
    "    ]  \n",
    "    if len(statenGDF)==0:\n",
    "        print(\"******************* GEOID \"+str(statenGeoidList[geoid])+\" Is in the staten island geoi shp but not in nyc shp\")\n",
    "    skipGeoid.extend(statenGDF.index.tolist())\n",
    "    statenGDF = statenGDF.reset_index(drop=True)\n",
    "    statenOutlineGDF = statenOutlineGDF.append(statenGDF)\n",
    "statenOutlineGDF.reset_index(drop=True)\n",
    "\n",
    "\n",
    "\n",
    "# D) POPULATE THE NEWLY CREATED COLS:\n",
    "print(\"Populating new cols...\")\n",
    "skipMonthIndex = []\n",
    "count = 0\n",
    "thisMonthPlotGDF = shapeGDF.copy()\n",
    "# 0) GO THROUGH EACH ROW OF THE MONTHLY CSV DATA AND PULL OUT ALL ROWS THAT ARE IN THE SAME MONTH -> FROM EACH MINI MONTH SEPERATED DF, SEPERATE FUTHER BY COUNTY NAME -> USE THE GEOID OF EACH COUNTY TO NAME THE GDF FILE\n",
    "for row in range(0,len(monthlyDF)):\n",
    "    thisMonthPlotGDF.drop(thisMonthPlotGDF.index, inplace=True)                           # resetting the month df for this new month\n",
    "    if row in skipMonthIndex:\n",
    "        continue\n",
    "\n",
    "    # 1) SAME MONTH SEPERATION:\n",
    "    thisMonthsDF = monthlyDF.loc[                                                                               # thisMonthsDF = df that contains all rows for that month-year\n",
    "        (monthlyDF['MonthYear']  == monthlyDF['MonthYear'][row]) \n",
    "    ]  \n",
    "\n",
    "    if len(thisMonthsDF) <= MIN_NUM_TRACTS_NEEDED_TO_PRINT:                                                                                  # If these r no reports for this month-year so skip\n",
    "        continue\n",
    "    skipMonthIndex.extend(thisMonthsDF.index.tolist())\n",
    "    thisMonthsDF = thisMonthsDF.reset_index(drop=True)\n",
    "    thisMonthGeoList = thisMonthsDF.GEOID_SCT.tolist()                                                          # need to put census tracts into an array, if i use directly from thisMonthsDF i get errors when there is no \n",
    "    thisMonthStr = monthlyDF['MonthYear'][row]\n",
    "\n",
    "    # 2) SAME COUNTY SEPERATION:\n",
    "    skipCountyIndex = []\n",
    "    for row2 in range(0,len(thisMonthsDF)):\n",
    "        if row2 in skipCountyIndex:\n",
    "            continue\n",
    "        thisMonthsCountyDF = thisMonthsDF.loc[                                                                               # thisMonthsCountyDF = df that contains all rows for that month-year\n",
    "            (thisMonthsDF['CountyName_2010']  == thisMonthsDF['CountyName_2010'][row2]) \n",
    "        ]      \n",
    "        if len(thisMonthsCountyDF) == 0:                                                                                  # If these r no reports for this month-year so skip\n",
    "            print(\"----------------- NO BLOCK FOR THIS COUNTY: \"+thisMonthsDF['CountyName_2010'][row2])\n",
    "            continue\n",
    "        skipCountyIndex.extend(thisMonthsCountyDF.index.tolist())\n",
    "        thisMonthsCountyDF = thisMonthsCountyDF.reset_index(drop=True)\n",
    "        thisCountyStr = monthlyDF['CountyName_2010'][row]\n",
    "\n",
    "        # 3) FROM THE SEPERATED COUNTY MINI DF -> FIND THE GEOID AND POPULATE THE COLS\n",
    "        skipCountyGeoIdIndex = []\n",
    "        for row3 in range(0,len(thisMonthsCountyDF)):\n",
    "            if row3 in skipCountyGeoIdIndex:\n",
    "                continue\n",
    "            thisMonthsCountyGeoGDF = shapeGDF.loc[                                                                               # thisMonthsCountyDF = df that contains all rows for that month-year\n",
    "                (shapeGDF[GDF_GEOID_COL]  == thisMonthsCountyDF[DF_GEOID_COL][row3]) \n",
    "            ]      \n",
    "            if len(thisMonthsCountyGeoGDF) == 0 and thisCountyStr != \"Westchester County\":                                                                                  # If these r no reports for this month-year so skip\n",
    "                print(\"----------------- NO BLOCK FOR THIS COUNTY: \")#+thisMonthsCountyGeoGDF[GDF_GEOID_COL][row3])\n",
    "                continue\n",
    "            skipCountyGeoIdIndex.extend(thisMonthsCountyGeoGDF.index.tolist())\n",
    "            thisMonthsCountyGeoGDF = thisMonthsCountyGeoGDF.reset_index(drop=True)\n",
    "            # 4) POPULATING THE COLS I ADDED\n",
    "            #  FROM THE MONTHLY CSV DATA FOR THE SAME GEOIDS\n",
    "            if len(thisMonthsCountyGeoGDF) != 0:\n",
    "                thisMonthsCountyGeoGDF.at[0, \"MonthYear\"] = thisMonthsCountyDF.loc[row3][\"MonthYear\"]\n",
    "                thisMonthsCountyGeoGDF.at[0, \"TotalMonthlyReport\"] = thisMonthsCountyDF.loc[row3][\"TotalReports\"]\n",
    "                thisMonthsCountyGeoGDF.at[0, \"CountyName\"] = thisMonthsCountyDF.loc[row3][\"CountyName_2010\"]\n",
    "                thisMonthsCountyGeoGDF.at[0, \"CensusBlockID_list\"] = thisMonthsCountyDF.loc[row3][\"CensusBlockID_list\"]\n",
    "                thisMonthsCountyGeoGDF.at[0, \"Ticket_list\"] = thisMonthsCountyDF.loc[row3][\"Ticket_list\"]\n",
    "                thisMonthsCountyGeoGDF.at[0, \"Classification_list\"] = thisMonthsCountyDF.loc[row3][\"Classification_list\"]\n",
    "                thisMonthsCountyGeoGDF.at[0, \"Zipcode_list\"] = thisMonthsCountyDF.loc[row3][\"Zipcode_list\"]\n",
    "                thisMonthsCountyGeoGDF.at[0, \"CountyTract\"] = thisMonthsCountyGeoGDF.iloc[0][\"CountyName\"]+\"-\"+str(thisMonthsCountyGeoGDF.iloc[0][\"namelsad\"]).split(\" \")[2]   # Add \"CountyName-TractNum\" to the col\n",
    "            thisMonthPlotGDF = thisMonthPlotGDF.append(thisMonthsCountyGeoGDF)\n",
    "        thisMonthPlotGDF = thisMonthPlotGDF.reset_index(drop=True)\n",
    "    countyTract_list = list()                                                            #\n",
    "    for i in range(0, len(thisMonthPlotGDF)):\n",
    "        countyTract_list.append(thisMonthPlotGDF.iloc[i][\"CountyTract\"])\n",
    "    thisMonthPlotGDF.to_csv(\"del_month.csv\")\n",
    "\n",
    "    # 5) PLOT THE MONTH'S DATA:\n",
    "    figx = 14\n",
    "    figy = 13\n",
    "    ax = shapeGDF.plot(alpha=0.05, edgecolor='black', linewidth = 0.6, figsize = (figx,figy))\n",
    "    ax = brooklynOutlineGDF.plot(alpha=0.2, ax=ax, figsize = (figx,figy), color=\"black\")\n",
    "    ax = statenOutlineGDF.plot(alpha=0.2, ax=ax, figsize = (figx,figy), color=\"black\")\n",
    "    map = thisMonthPlotGDF.plot(column='TotalMonthlyReport',cmap = 'Reds', edgecolor='black', linewidth = 0.3, figsize = (figx,figy),legend = True, ax=ax)#, ax=ax, alpha=1) #10,8\n",
    "    map.set_title(label = 'Number of Gas Leak Reports per Census Tract for\\n{0}\\n(Showing {2}/{3} GeoIDs-Census Tracts)'.format(thisMonthStr, len(countyTract_list), len(thisMonthPlotGDF), len(thisMonthsDF)), fontdict={'fontsize': 20}, loc='center')\n",
    "\n",
    "#%%\n",
    "\n",
    "\n",
    "    \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.7.5 64-bit",
   "language": "python",
   "name": "python37564bit8e88b8f881e84216b896abc70a00718d"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
